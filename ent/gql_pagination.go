// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/artmisxyz/legolas/ent/event"
	"github.com/artmisxyz/legolas/ent/uniswapv3collect"
	"github.com/artmisxyz/legolas/ent/uniswapv3decreaseliqudity"
	"github.com/artmisxyz/legolas/ent/uniswapv3increaseliqudity"
	"github.com/artmisxyz/legolas/ent/uniswapv3poolburn"
	"github.com/artmisxyz/legolas/ent/uniswapv3poolcreated"
	"github.com/artmisxyz/legolas/ent/uniswapv3poolflash"
	"github.com/artmisxyz/legolas/ent/uniswapv3poolinitialize"
	"github.com/artmisxyz/legolas/ent/uniswapv3poolmint"
	"github.com/artmisxyz/legolas/ent/uniswapv3poolswap"
	"github.com/artmisxyz/legolas/ent/uniswapv3transfer"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    int   `msgpack:"i"`
	Value Value `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// EventEdge is the edge representation of Event.
type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EventConnection is the connection containing edges to Event.
type EventConnection struct {
	Edges      []*EventEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// EventPaginateOption enables pagination customization.
type EventPaginateOption func(*eventPager) error

// WithEventOrder configures pagination ordering.
func WithEventOrder(order *EventOrder) EventPaginateOption {
	if order == nil {
		order = DefaultEventOrder
	}
	o := *order
	return func(pager *eventPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventFilter configures pagination filter.
func WithEventFilter(filter func(*EventQuery) (*EventQuery, error)) EventPaginateOption {
	return func(pager *eventPager) error {
		if filter == nil {
			return errors.New("EventQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventPager struct {
	order  *EventOrder
	filter func(*EventQuery) (*EventQuery, error)
}

func newEventPager(opts []EventPaginateOption) (*eventPager, error) {
	pager := &eventPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventOrder
	}
	return pager, nil
}

func (p *eventPager) applyFilter(query *EventQuery) (*EventQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventPager) toCursor(e *Event) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *eventPager) applyCursors(query *EventQuery, after, before *Cursor) *EventQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEventOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *eventPager) applyOrder(query *EventQuery, reverse bool) *EventQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEventOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEventOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Event.
func (e *EventQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventPaginateOption,
) (*EventConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EventConnection{Edges: []*EventEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Event
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Event {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Event {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EventEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EventEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// EventOrderField defines the ordering field of Event.
type EventOrderField struct {
	field    string
	toCursor func(*Event) Cursor
}

// EventOrder defines the ordering of Event.
type EventOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EventOrderField `json:"field"`
}

// DefaultEventOrder is the default ordering of Event.
var DefaultEventOrder = &EventOrder{
	Direction: OrderDirectionAsc,
	Field: &EventOrderField{
		field: event.FieldID,
		toCursor: func(e *Event) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Event into EventEdge.
func (e *Event) ToEdge(order *EventOrder) *EventEdge {
	if order == nil {
		order = DefaultEventOrder
	}
	return &EventEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// UniswapV3CollectEdge is the edge representation of UniswapV3Collect.
type UniswapV3CollectEdge struct {
	Node   *UniswapV3Collect `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// UniswapV3CollectConnection is the connection containing edges to UniswapV3Collect.
type UniswapV3CollectConnection struct {
	Edges      []*UniswapV3CollectEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

// UniswapV3CollectPaginateOption enables pagination customization.
type UniswapV3CollectPaginateOption func(*uniswapV3CollectPager) error

// WithUniswapV3CollectOrder configures pagination ordering.
func WithUniswapV3CollectOrder(order *UniswapV3CollectOrder) UniswapV3CollectPaginateOption {
	if order == nil {
		order = DefaultUniswapV3CollectOrder
	}
	o := *order
	return func(pager *uniswapV3CollectPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3CollectOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3CollectFilter configures pagination filter.
func WithUniswapV3CollectFilter(filter func(*UniswapV3CollectQuery) (*UniswapV3CollectQuery, error)) UniswapV3CollectPaginateOption {
	return func(pager *uniswapV3CollectPager) error {
		if filter == nil {
			return errors.New("UniswapV3CollectQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3CollectPager struct {
	order  *UniswapV3CollectOrder
	filter func(*UniswapV3CollectQuery) (*UniswapV3CollectQuery, error)
}

func newUniswapV3CollectPager(opts []UniswapV3CollectPaginateOption) (*uniswapV3CollectPager, error) {
	pager := &uniswapV3CollectPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3CollectOrder
	}
	return pager, nil
}

func (p *uniswapV3CollectPager) applyFilter(query *UniswapV3CollectQuery) (*UniswapV3CollectQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3CollectPager) toCursor(uv *UniswapV3Collect) Cursor {
	return p.order.Field.toCursor(uv)
}

func (p *uniswapV3CollectPager) applyCursors(query *UniswapV3CollectQuery, after, before *Cursor) *UniswapV3CollectQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3CollectOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3CollectPager) applyOrder(query *UniswapV3CollectQuery, reverse bool) *UniswapV3CollectQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3CollectOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3CollectOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3Collect.
func (uv *UniswapV3CollectQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3CollectPaginateOption,
) (*UniswapV3CollectConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3CollectPager(opts)
	if err != nil {
		return nil, err
	}

	if uv, err = pager.applyFilter(uv); err != nil {
		return nil, err
	}

	conn := &UniswapV3CollectConnection{Edges: []*UniswapV3CollectEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uv.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uv.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uv = pager.applyCursors(uv, after, before)
	uv = pager.applyOrder(uv, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uv = uv.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uv = uv.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uv.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3Collect
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3Collect {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3Collect {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3CollectEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3CollectEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3CollectOrderField defines the ordering field of UniswapV3Collect.
type UniswapV3CollectOrderField struct {
	field    string
	toCursor func(*UniswapV3Collect) Cursor
}

// UniswapV3CollectOrder defines the ordering of UniswapV3Collect.
type UniswapV3CollectOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *UniswapV3CollectOrderField `json:"field"`
}

// DefaultUniswapV3CollectOrder is the default ordering of UniswapV3Collect.
var DefaultUniswapV3CollectOrder = &UniswapV3CollectOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3CollectOrderField{
		field: uniswapv3collect.FieldID,
		toCursor: func(uv *UniswapV3Collect) Cursor {
			return Cursor{ID: uv.ID}
		},
	},
}

// ToEdge converts UniswapV3Collect into UniswapV3CollectEdge.
func (uv *UniswapV3Collect) ToEdge(order *UniswapV3CollectOrder) *UniswapV3CollectEdge {
	if order == nil {
		order = DefaultUniswapV3CollectOrder
	}
	return &UniswapV3CollectEdge{
		Node:   uv,
		Cursor: order.Field.toCursor(uv),
	}
}

// UniswapV3DecreaseLiqudityEdge is the edge representation of UniswapV3DecreaseLiqudity.
type UniswapV3DecreaseLiqudityEdge struct {
	Node   *UniswapV3DecreaseLiqudity `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// UniswapV3DecreaseLiqudityConnection is the connection containing edges to UniswapV3DecreaseLiqudity.
type UniswapV3DecreaseLiqudityConnection struct {
	Edges      []*UniswapV3DecreaseLiqudityEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

// UniswapV3DecreaseLiqudityPaginateOption enables pagination customization.
type UniswapV3DecreaseLiqudityPaginateOption func(*uniswapV3DecreaseLiqudityPager) error

// WithUniswapV3DecreaseLiqudityOrder configures pagination ordering.
func WithUniswapV3DecreaseLiqudityOrder(order *UniswapV3DecreaseLiqudityOrder) UniswapV3DecreaseLiqudityPaginateOption {
	if order == nil {
		order = DefaultUniswapV3DecreaseLiqudityOrder
	}
	o := *order
	return func(pager *uniswapV3DecreaseLiqudityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3DecreaseLiqudityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3DecreaseLiqudityFilter configures pagination filter.
func WithUniswapV3DecreaseLiqudityFilter(filter func(*UniswapV3DecreaseLiqudityQuery) (*UniswapV3DecreaseLiqudityQuery, error)) UniswapV3DecreaseLiqudityPaginateOption {
	return func(pager *uniswapV3DecreaseLiqudityPager) error {
		if filter == nil {
			return errors.New("UniswapV3DecreaseLiqudityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3DecreaseLiqudityPager struct {
	order  *UniswapV3DecreaseLiqudityOrder
	filter func(*UniswapV3DecreaseLiqudityQuery) (*UniswapV3DecreaseLiqudityQuery, error)
}

func newUniswapV3DecreaseLiqudityPager(opts []UniswapV3DecreaseLiqudityPaginateOption) (*uniswapV3DecreaseLiqudityPager, error) {
	pager := &uniswapV3DecreaseLiqudityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3DecreaseLiqudityOrder
	}
	return pager, nil
}

func (p *uniswapV3DecreaseLiqudityPager) applyFilter(query *UniswapV3DecreaseLiqudityQuery) (*UniswapV3DecreaseLiqudityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3DecreaseLiqudityPager) toCursor(uvl *UniswapV3DecreaseLiqudity) Cursor {
	return p.order.Field.toCursor(uvl)
}

func (p *uniswapV3DecreaseLiqudityPager) applyCursors(query *UniswapV3DecreaseLiqudityQuery, after, before *Cursor) *UniswapV3DecreaseLiqudityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3DecreaseLiqudityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3DecreaseLiqudityPager) applyOrder(query *UniswapV3DecreaseLiqudityQuery, reverse bool) *UniswapV3DecreaseLiqudityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3DecreaseLiqudityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3DecreaseLiqudityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3DecreaseLiqudity.
func (uvl *UniswapV3DecreaseLiqudityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3DecreaseLiqudityPaginateOption,
) (*UniswapV3DecreaseLiqudityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3DecreaseLiqudityPager(opts)
	if err != nil {
		return nil, err
	}

	if uvl, err = pager.applyFilter(uvl); err != nil {
		return nil, err
	}

	conn := &UniswapV3DecreaseLiqudityConnection{Edges: []*UniswapV3DecreaseLiqudityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvl = pager.applyCursors(uvl, after, before)
	uvl = pager.applyOrder(uvl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvl = uvl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvl = uvl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3DecreaseLiqudity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3DecreaseLiqudity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3DecreaseLiqudity {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3DecreaseLiqudityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3DecreaseLiqudityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3DecreaseLiqudityOrderField defines the ordering field of UniswapV3DecreaseLiqudity.
type UniswapV3DecreaseLiqudityOrderField struct {
	field    string
	toCursor func(*UniswapV3DecreaseLiqudity) Cursor
}

// UniswapV3DecreaseLiqudityOrder defines the ordering of UniswapV3DecreaseLiqudity.
type UniswapV3DecreaseLiqudityOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *UniswapV3DecreaseLiqudityOrderField `json:"field"`
}

// DefaultUniswapV3DecreaseLiqudityOrder is the default ordering of UniswapV3DecreaseLiqudity.
var DefaultUniswapV3DecreaseLiqudityOrder = &UniswapV3DecreaseLiqudityOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3DecreaseLiqudityOrderField{
		field: uniswapv3decreaseliqudity.FieldID,
		toCursor: func(uvl *UniswapV3DecreaseLiqudity) Cursor {
			return Cursor{ID: uvl.ID}
		},
	},
}

// ToEdge converts UniswapV3DecreaseLiqudity into UniswapV3DecreaseLiqudityEdge.
func (uvl *UniswapV3DecreaseLiqudity) ToEdge(order *UniswapV3DecreaseLiqudityOrder) *UniswapV3DecreaseLiqudityEdge {
	if order == nil {
		order = DefaultUniswapV3DecreaseLiqudityOrder
	}
	return &UniswapV3DecreaseLiqudityEdge{
		Node:   uvl,
		Cursor: order.Field.toCursor(uvl),
	}
}

// UniswapV3IncreaseLiqudityEdge is the edge representation of UniswapV3IncreaseLiqudity.
type UniswapV3IncreaseLiqudityEdge struct {
	Node   *UniswapV3IncreaseLiqudity `json:"node"`
	Cursor Cursor                     `json:"cursor"`
}

// UniswapV3IncreaseLiqudityConnection is the connection containing edges to UniswapV3IncreaseLiqudity.
type UniswapV3IncreaseLiqudityConnection struct {
	Edges      []*UniswapV3IncreaseLiqudityEdge `json:"edges"`
	PageInfo   PageInfo                         `json:"pageInfo"`
	TotalCount int                              `json:"totalCount"`
}

// UniswapV3IncreaseLiqudityPaginateOption enables pagination customization.
type UniswapV3IncreaseLiqudityPaginateOption func(*uniswapV3IncreaseLiqudityPager) error

// WithUniswapV3IncreaseLiqudityOrder configures pagination ordering.
func WithUniswapV3IncreaseLiqudityOrder(order *UniswapV3IncreaseLiqudityOrder) UniswapV3IncreaseLiqudityPaginateOption {
	if order == nil {
		order = DefaultUniswapV3IncreaseLiqudityOrder
	}
	o := *order
	return func(pager *uniswapV3IncreaseLiqudityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3IncreaseLiqudityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3IncreaseLiqudityFilter configures pagination filter.
func WithUniswapV3IncreaseLiqudityFilter(filter func(*UniswapV3IncreaseLiqudityQuery) (*UniswapV3IncreaseLiqudityQuery, error)) UniswapV3IncreaseLiqudityPaginateOption {
	return func(pager *uniswapV3IncreaseLiqudityPager) error {
		if filter == nil {
			return errors.New("UniswapV3IncreaseLiqudityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3IncreaseLiqudityPager struct {
	order  *UniswapV3IncreaseLiqudityOrder
	filter func(*UniswapV3IncreaseLiqudityQuery) (*UniswapV3IncreaseLiqudityQuery, error)
}

func newUniswapV3IncreaseLiqudityPager(opts []UniswapV3IncreaseLiqudityPaginateOption) (*uniswapV3IncreaseLiqudityPager, error) {
	pager := &uniswapV3IncreaseLiqudityPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3IncreaseLiqudityOrder
	}
	return pager, nil
}

func (p *uniswapV3IncreaseLiqudityPager) applyFilter(query *UniswapV3IncreaseLiqudityQuery) (*UniswapV3IncreaseLiqudityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3IncreaseLiqudityPager) toCursor(uvl *UniswapV3IncreaseLiqudity) Cursor {
	return p.order.Field.toCursor(uvl)
}

func (p *uniswapV3IncreaseLiqudityPager) applyCursors(query *UniswapV3IncreaseLiqudityQuery, after, before *Cursor) *UniswapV3IncreaseLiqudityQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3IncreaseLiqudityOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3IncreaseLiqudityPager) applyOrder(query *UniswapV3IncreaseLiqudityQuery, reverse bool) *UniswapV3IncreaseLiqudityQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3IncreaseLiqudityOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3IncreaseLiqudityOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3IncreaseLiqudity.
func (uvl *UniswapV3IncreaseLiqudityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3IncreaseLiqudityPaginateOption,
) (*UniswapV3IncreaseLiqudityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3IncreaseLiqudityPager(opts)
	if err != nil {
		return nil, err
	}

	if uvl, err = pager.applyFilter(uvl); err != nil {
		return nil, err
	}

	conn := &UniswapV3IncreaseLiqudityConnection{Edges: []*UniswapV3IncreaseLiqudityEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvl.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvl.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvl = pager.applyCursors(uvl, after, before)
	uvl = pager.applyOrder(uvl, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvl = uvl.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvl = uvl.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvl.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3IncreaseLiqudity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3IncreaseLiqudity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3IncreaseLiqudity {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3IncreaseLiqudityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3IncreaseLiqudityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3IncreaseLiqudityOrderField defines the ordering field of UniswapV3IncreaseLiqudity.
type UniswapV3IncreaseLiqudityOrderField struct {
	field    string
	toCursor func(*UniswapV3IncreaseLiqudity) Cursor
}

// UniswapV3IncreaseLiqudityOrder defines the ordering of UniswapV3IncreaseLiqudity.
type UniswapV3IncreaseLiqudityOrder struct {
	Direction OrderDirection                       `json:"direction"`
	Field     *UniswapV3IncreaseLiqudityOrderField `json:"field"`
}

// DefaultUniswapV3IncreaseLiqudityOrder is the default ordering of UniswapV3IncreaseLiqudity.
var DefaultUniswapV3IncreaseLiqudityOrder = &UniswapV3IncreaseLiqudityOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3IncreaseLiqudityOrderField{
		field: uniswapv3increaseliqudity.FieldID,
		toCursor: func(uvl *UniswapV3IncreaseLiqudity) Cursor {
			return Cursor{ID: uvl.ID}
		},
	},
}

// ToEdge converts UniswapV3IncreaseLiqudity into UniswapV3IncreaseLiqudityEdge.
func (uvl *UniswapV3IncreaseLiqudity) ToEdge(order *UniswapV3IncreaseLiqudityOrder) *UniswapV3IncreaseLiqudityEdge {
	if order == nil {
		order = DefaultUniswapV3IncreaseLiqudityOrder
	}
	return &UniswapV3IncreaseLiqudityEdge{
		Node:   uvl,
		Cursor: order.Field.toCursor(uvl),
	}
}

// UniswapV3PoolBurnEdge is the edge representation of UniswapV3PoolBurn.
type UniswapV3PoolBurnEdge struct {
	Node   *UniswapV3PoolBurn `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// UniswapV3PoolBurnConnection is the connection containing edges to UniswapV3PoolBurn.
type UniswapV3PoolBurnConnection struct {
	Edges      []*UniswapV3PoolBurnEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// UniswapV3PoolBurnPaginateOption enables pagination customization.
type UniswapV3PoolBurnPaginateOption func(*uniswapV3PoolBurnPager) error

// WithUniswapV3PoolBurnOrder configures pagination ordering.
func WithUniswapV3PoolBurnOrder(order *UniswapV3PoolBurnOrder) UniswapV3PoolBurnPaginateOption {
	if order == nil {
		order = DefaultUniswapV3PoolBurnOrder
	}
	o := *order
	return func(pager *uniswapV3PoolBurnPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3PoolBurnOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3PoolBurnFilter configures pagination filter.
func WithUniswapV3PoolBurnFilter(filter func(*UniswapV3PoolBurnQuery) (*UniswapV3PoolBurnQuery, error)) UniswapV3PoolBurnPaginateOption {
	return func(pager *uniswapV3PoolBurnPager) error {
		if filter == nil {
			return errors.New("UniswapV3PoolBurnQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3PoolBurnPager struct {
	order  *UniswapV3PoolBurnOrder
	filter func(*UniswapV3PoolBurnQuery) (*UniswapV3PoolBurnQuery, error)
}

func newUniswapV3PoolBurnPager(opts []UniswapV3PoolBurnPaginateOption) (*uniswapV3PoolBurnPager, error) {
	pager := &uniswapV3PoolBurnPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3PoolBurnOrder
	}
	return pager, nil
}

func (p *uniswapV3PoolBurnPager) applyFilter(query *UniswapV3PoolBurnQuery) (*UniswapV3PoolBurnQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3PoolBurnPager) toCursor(uvb *UniswapV3PoolBurn) Cursor {
	return p.order.Field.toCursor(uvb)
}

func (p *uniswapV3PoolBurnPager) applyCursors(query *UniswapV3PoolBurnQuery, after, before *Cursor) *UniswapV3PoolBurnQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3PoolBurnOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3PoolBurnPager) applyOrder(query *UniswapV3PoolBurnQuery, reverse bool) *UniswapV3PoolBurnQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3PoolBurnOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3PoolBurnOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3PoolBurn.
func (uvb *UniswapV3PoolBurnQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3PoolBurnPaginateOption,
) (*UniswapV3PoolBurnConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3PoolBurnPager(opts)
	if err != nil {
		return nil, err
	}

	if uvb, err = pager.applyFilter(uvb); err != nil {
		return nil, err
	}

	conn := &UniswapV3PoolBurnConnection{Edges: []*UniswapV3PoolBurnEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvb.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvb.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvb = pager.applyCursors(uvb, after, before)
	uvb = pager.applyOrder(uvb, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvb = uvb.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvb = uvb.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvb.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3PoolBurn
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3PoolBurn {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3PoolBurn {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3PoolBurnEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3PoolBurnEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3PoolBurnOrderField defines the ordering field of UniswapV3PoolBurn.
type UniswapV3PoolBurnOrderField struct {
	field    string
	toCursor func(*UniswapV3PoolBurn) Cursor
}

// UniswapV3PoolBurnOrder defines the ordering of UniswapV3PoolBurn.
type UniswapV3PoolBurnOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *UniswapV3PoolBurnOrderField `json:"field"`
}

// DefaultUniswapV3PoolBurnOrder is the default ordering of UniswapV3PoolBurn.
var DefaultUniswapV3PoolBurnOrder = &UniswapV3PoolBurnOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3PoolBurnOrderField{
		field: uniswapv3poolburn.FieldID,
		toCursor: func(uvb *UniswapV3PoolBurn) Cursor {
			return Cursor{ID: uvb.ID}
		},
	},
}

// ToEdge converts UniswapV3PoolBurn into UniswapV3PoolBurnEdge.
func (uvb *UniswapV3PoolBurn) ToEdge(order *UniswapV3PoolBurnOrder) *UniswapV3PoolBurnEdge {
	if order == nil {
		order = DefaultUniswapV3PoolBurnOrder
	}
	return &UniswapV3PoolBurnEdge{
		Node:   uvb,
		Cursor: order.Field.toCursor(uvb),
	}
}

// UniswapV3PoolCreatedEdge is the edge representation of UniswapV3PoolCreated.
type UniswapV3PoolCreatedEdge struct {
	Node   *UniswapV3PoolCreated `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// UniswapV3PoolCreatedConnection is the connection containing edges to UniswapV3PoolCreated.
type UniswapV3PoolCreatedConnection struct {
	Edges      []*UniswapV3PoolCreatedEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

// UniswapV3PoolCreatedPaginateOption enables pagination customization.
type UniswapV3PoolCreatedPaginateOption func(*uniswapV3PoolCreatedPager) error

// WithUniswapV3PoolCreatedOrder configures pagination ordering.
func WithUniswapV3PoolCreatedOrder(order *UniswapV3PoolCreatedOrder) UniswapV3PoolCreatedPaginateOption {
	if order == nil {
		order = DefaultUniswapV3PoolCreatedOrder
	}
	o := *order
	return func(pager *uniswapV3PoolCreatedPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3PoolCreatedOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3PoolCreatedFilter configures pagination filter.
func WithUniswapV3PoolCreatedFilter(filter func(*UniswapV3PoolCreatedQuery) (*UniswapV3PoolCreatedQuery, error)) UniswapV3PoolCreatedPaginateOption {
	return func(pager *uniswapV3PoolCreatedPager) error {
		if filter == nil {
			return errors.New("UniswapV3PoolCreatedQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3PoolCreatedPager struct {
	order  *UniswapV3PoolCreatedOrder
	filter func(*UniswapV3PoolCreatedQuery) (*UniswapV3PoolCreatedQuery, error)
}

func newUniswapV3PoolCreatedPager(opts []UniswapV3PoolCreatedPaginateOption) (*uniswapV3PoolCreatedPager, error) {
	pager := &uniswapV3PoolCreatedPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3PoolCreatedOrder
	}
	return pager, nil
}

func (p *uniswapV3PoolCreatedPager) applyFilter(query *UniswapV3PoolCreatedQuery) (*UniswapV3PoolCreatedQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3PoolCreatedPager) toCursor(uvc *UniswapV3PoolCreated) Cursor {
	return p.order.Field.toCursor(uvc)
}

func (p *uniswapV3PoolCreatedPager) applyCursors(query *UniswapV3PoolCreatedQuery, after, before *Cursor) *UniswapV3PoolCreatedQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3PoolCreatedOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3PoolCreatedPager) applyOrder(query *UniswapV3PoolCreatedQuery, reverse bool) *UniswapV3PoolCreatedQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3PoolCreatedOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3PoolCreatedOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3PoolCreated.
func (uvc *UniswapV3PoolCreatedQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3PoolCreatedPaginateOption,
) (*UniswapV3PoolCreatedConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3PoolCreatedPager(opts)
	if err != nil {
		return nil, err
	}

	if uvc, err = pager.applyFilter(uvc); err != nil {
		return nil, err
	}

	conn := &UniswapV3PoolCreatedConnection{Edges: []*UniswapV3PoolCreatedEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvc.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvc.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvc = pager.applyCursors(uvc, after, before)
	uvc = pager.applyOrder(uvc, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvc = uvc.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvc = uvc.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvc.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3PoolCreated
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3PoolCreated {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3PoolCreated {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3PoolCreatedEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3PoolCreatedEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3PoolCreatedOrderField defines the ordering field of UniswapV3PoolCreated.
type UniswapV3PoolCreatedOrderField struct {
	field    string
	toCursor func(*UniswapV3PoolCreated) Cursor
}

// UniswapV3PoolCreatedOrder defines the ordering of UniswapV3PoolCreated.
type UniswapV3PoolCreatedOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *UniswapV3PoolCreatedOrderField `json:"field"`
}

// DefaultUniswapV3PoolCreatedOrder is the default ordering of UniswapV3PoolCreated.
var DefaultUniswapV3PoolCreatedOrder = &UniswapV3PoolCreatedOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3PoolCreatedOrderField{
		field: uniswapv3poolcreated.FieldID,
		toCursor: func(uvc *UniswapV3PoolCreated) Cursor {
			return Cursor{ID: uvc.ID}
		},
	},
}

// ToEdge converts UniswapV3PoolCreated into UniswapV3PoolCreatedEdge.
func (uvc *UniswapV3PoolCreated) ToEdge(order *UniswapV3PoolCreatedOrder) *UniswapV3PoolCreatedEdge {
	if order == nil {
		order = DefaultUniswapV3PoolCreatedOrder
	}
	return &UniswapV3PoolCreatedEdge{
		Node:   uvc,
		Cursor: order.Field.toCursor(uvc),
	}
}

// UniswapV3PoolFlashEdge is the edge representation of UniswapV3PoolFlash.
type UniswapV3PoolFlashEdge struct {
	Node   *UniswapV3PoolFlash `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// UniswapV3PoolFlashConnection is the connection containing edges to UniswapV3PoolFlash.
type UniswapV3PoolFlashConnection struct {
	Edges      []*UniswapV3PoolFlashEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

// UniswapV3PoolFlashPaginateOption enables pagination customization.
type UniswapV3PoolFlashPaginateOption func(*uniswapV3PoolFlashPager) error

// WithUniswapV3PoolFlashOrder configures pagination ordering.
func WithUniswapV3PoolFlashOrder(order *UniswapV3PoolFlashOrder) UniswapV3PoolFlashPaginateOption {
	if order == nil {
		order = DefaultUniswapV3PoolFlashOrder
	}
	o := *order
	return func(pager *uniswapV3PoolFlashPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3PoolFlashOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3PoolFlashFilter configures pagination filter.
func WithUniswapV3PoolFlashFilter(filter func(*UniswapV3PoolFlashQuery) (*UniswapV3PoolFlashQuery, error)) UniswapV3PoolFlashPaginateOption {
	return func(pager *uniswapV3PoolFlashPager) error {
		if filter == nil {
			return errors.New("UniswapV3PoolFlashQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3PoolFlashPager struct {
	order  *UniswapV3PoolFlashOrder
	filter func(*UniswapV3PoolFlashQuery) (*UniswapV3PoolFlashQuery, error)
}

func newUniswapV3PoolFlashPager(opts []UniswapV3PoolFlashPaginateOption) (*uniswapV3PoolFlashPager, error) {
	pager := &uniswapV3PoolFlashPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3PoolFlashOrder
	}
	return pager, nil
}

func (p *uniswapV3PoolFlashPager) applyFilter(query *UniswapV3PoolFlashQuery) (*UniswapV3PoolFlashQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3PoolFlashPager) toCursor(uvf *UniswapV3PoolFlash) Cursor {
	return p.order.Field.toCursor(uvf)
}

func (p *uniswapV3PoolFlashPager) applyCursors(query *UniswapV3PoolFlashQuery, after, before *Cursor) *UniswapV3PoolFlashQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3PoolFlashOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3PoolFlashPager) applyOrder(query *UniswapV3PoolFlashQuery, reverse bool) *UniswapV3PoolFlashQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3PoolFlashOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3PoolFlashOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3PoolFlash.
func (uvf *UniswapV3PoolFlashQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3PoolFlashPaginateOption,
) (*UniswapV3PoolFlashConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3PoolFlashPager(opts)
	if err != nil {
		return nil, err
	}

	if uvf, err = pager.applyFilter(uvf); err != nil {
		return nil, err
	}

	conn := &UniswapV3PoolFlashConnection{Edges: []*UniswapV3PoolFlashEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvf.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvf.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvf = pager.applyCursors(uvf, after, before)
	uvf = pager.applyOrder(uvf, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvf = uvf.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvf = uvf.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvf.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3PoolFlash
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3PoolFlash {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3PoolFlash {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3PoolFlashEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3PoolFlashEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3PoolFlashOrderField defines the ordering field of UniswapV3PoolFlash.
type UniswapV3PoolFlashOrderField struct {
	field    string
	toCursor func(*UniswapV3PoolFlash) Cursor
}

// UniswapV3PoolFlashOrder defines the ordering of UniswapV3PoolFlash.
type UniswapV3PoolFlashOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *UniswapV3PoolFlashOrderField `json:"field"`
}

// DefaultUniswapV3PoolFlashOrder is the default ordering of UniswapV3PoolFlash.
var DefaultUniswapV3PoolFlashOrder = &UniswapV3PoolFlashOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3PoolFlashOrderField{
		field: uniswapv3poolflash.FieldID,
		toCursor: func(uvf *UniswapV3PoolFlash) Cursor {
			return Cursor{ID: uvf.ID}
		},
	},
}

// ToEdge converts UniswapV3PoolFlash into UniswapV3PoolFlashEdge.
func (uvf *UniswapV3PoolFlash) ToEdge(order *UniswapV3PoolFlashOrder) *UniswapV3PoolFlashEdge {
	if order == nil {
		order = DefaultUniswapV3PoolFlashOrder
	}
	return &UniswapV3PoolFlashEdge{
		Node:   uvf,
		Cursor: order.Field.toCursor(uvf),
	}
}

// UniswapV3PoolInitializeEdge is the edge representation of UniswapV3PoolInitialize.
type UniswapV3PoolInitializeEdge struct {
	Node   *UniswapV3PoolInitialize `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// UniswapV3PoolInitializeConnection is the connection containing edges to UniswapV3PoolInitialize.
type UniswapV3PoolInitializeConnection struct {
	Edges      []*UniswapV3PoolInitializeEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

// UniswapV3PoolInitializePaginateOption enables pagination customization.
type UniswapV3PoolInitializePaginateOption func(*uniswapV3PoolInitializePager) error

// WithUniswapV3PoolInitializeOrder configures pagination ordering.
func WithUniswapV3PoolInitializeOrder(order *UniswapV3PoolInitializeOrder) UniswapV3PoolInitializePaginateOption {
	if order == nil {
		order = DefaultUniswapV3PoolInitializeOrder
	}
	o := *order
	return func(pager *uniswapV3PoolInitializePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3PoolInitializeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3PoolInitializeFilter configures pagination filter.
func WithUniswapV3PoolInitializeFilter(filter func(*UniswapV3PoolInitializeQuery) (*UniswapV3PoolInitializeQuery, error)) UniswapV3PoolInitializePaginateOption {
	return func(pager *uniswapV3PoolInitializePager) error {
		if filter == nil {
			return errors.New("UniswapV3PoolInitializeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3PoolInitializePager struct {
	order  *UniswapV3PoolInitializeOrder
	filter func(*UniswapV3PoolInitializeQuery) (*UniswapV3PoolInitializeQuery, error)
}

func newUniswapV3PoolInitializePager(opts []UniswapV3PoolInitializePaginateOption) (*uniswapV3PoolInitializePager, error) {
	pager := &uniswapV3PoolInitializePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3PoolInitializeOrder
	}
	return pager, nil
}

func (p *uniswapV3PoolInitializePager) applyFilter(query *UniswapV3PoolInitializeQuery) (*UniswapV3PoolInitializeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3PoolInitializePager) toCursor(uvi *UniswapV3PoolInitialize) Cursor {
	return p.order.Field.toCursor(uvi)
}

func (p *uniswapV3PoolInitializePager) applyCursors(query *UniswapV3PoolInitializeQuery, after, before *Cursor) *UniswapV3PoolInitializeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3PoolInitializeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3PoolInitializePager) applyOrder(query *UniswapV3PoolInitializeQuery, reverse bool) *UniswapV3PoolInitializeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3PoolInitializeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3PoolInitializeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3PoolInitialize.
func (uvi *UniswapV3PoolInitializeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3PoolInitializePaginateOption,
) (*UniswapV3PoolInitializeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3PoolInitializePager(opts)
	if err != nil {
		return nil, err
	}

	if uvi, err = pager.applyFilter(uvi); err != nil {
		return nil, err
	}

	conn := &UniswapV3PoolInitializeConnection{Edges: []*UniswapV3PoolInitializeEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvi.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvi.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvi = pager.applyCursors(uvi, after, before)
	uvi = pager.applyOrder(uvi, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvi = uvi.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvi = uvi.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvi.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3PoolInitialize
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3PoolInitialize {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3PoolInitialize {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3PoolInitializeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3PoolInitializeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3PoolInitializeOrderField defines the ordering field of UniswapV3PoolInitialize.
type UniswapV3PoolInitializeOrderField struct {
	field    string
	toCursor func(*UniswapV3PoolInitialize) Cursor
}

// UniswapV3PoolInitializeOrder defines the ordering of UniswapV3PoolInitialize.
type UniswapV3PoolInitializeOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *UniswapV3PoolInitializeOrderField `json:"field"`
}

// DefaultUniswapV3PoolInitializeOrder is the default ordering of UniswapV3PoolInitialize.
var DefaultUniswapV3PoolInitializeOrder = &UniswapV3PoolInitializeOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3PoolInitializeOrderField{
		field: uniswapv3poolinitialize.FieldID,
		toCursor: func(uvi *UniswapV3PoolInitialize) Cursor {
			return Cursor{ID: uvi.ID}
		},
	},
}

// ToEdge converts UniswapV3PoolInitialize into UniswapV3PoolInitializeEdge.
func (uvi *UniswapV3PoolInitialize) ToEdge(order *UniswapV3PoolInitializeOrder) *UniswapV3PoolInitializeEdge {
	if order == nil {
		order = DefaultUniswapV3PoolInitializeOrder
	}
	return &UniswapV3PoolInitializeEdge{
		Node:   uvi,
		Cursor: order.Field.toCursor(uvi),
	}
}

// UniswapV3PoolMintEdge is the edge representation of UniswapV3PoolMint.
type UniswapV3PoolMintEdge struct {
	Node   *UniswapV3PoolMint `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// UniswapV3PoolMintConnection is the connection containing edges to UniswapV3PoolMint.
type UniswapV3PoolMintConnection struct {
	Edges      []*UniswapV3PoolMintEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// UniswapV3PoolMintPaginateOption enables pagination customization.
type UniswapV3PoolMintPaginateOption func(*uniswapV3PoolMintPager) error

// WithUniswapV3PoolMintOrder configures pagination ordering.
func WithUniswapV3PoolMintOrder(order *UniswapV3PoolMintOrder) UniswapV3PoolMintPaginateOption {
	if order == nil {
		order = DefaultUniswapV3PoolMintOrder
	}
	o := *order
	return func(pager *uniswapV3PoolMintPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3PoolMintOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3PoolMintFilter configures pagination filter.
func WithUniswapV3PoolMintFilter(filter func(*UniswapV3PoolMintQuery) (*UniswapV3PoolMintQuery, error)) UniswapV3PoolMintPaginateOption {
	return func(pager *uniswapV3PoolMintPager) error {
		if filter == nil {
			return errors.New("UniswapV3PoolMintQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3PoolMintPager struct {
	order  *UniswapV3PoolMintOrder
	filter func(*UniswapV3PoolMintQuery) (*UniswapV3PoolMintQuery, error)
}

func newUniswapV3PoolMintPager(opts []UniswapV3PoolMintPaginateOption) (*uniswapV3PoolMintPager, error) {
	pager := &uniswapV3PoolMintPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3PoolMintOrder
	}
	return pager, nil
}

func (p *uniswapV3PoolMintPager) applyFilter(query *UniswapV3PoolMintQuery) (*UniswapV3PoolMintQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3PoolMintPager) toCursor(uvm *UniswapV3PoolMint) Cursor {
	return p.order.Field.toCursor(uvm)
}

func (p *uniswapV3PoolMintPager) applyCursors(query *UniswapV3PoolMintQuery, after, before *Cursor) *UniswapV3PoolMintQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3PoolMintOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3PoolMintPager) applyOrder(query *UniswapV3PoolMintQuery, reverse bool) *UniswapV3PoolMintQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3PoolMintOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3PoolMintOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3PoolMint.
func (uvm *UniswapV3PoolMintQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3PoolMintPaginateOption,
) (*UniswapV3PoolMintConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3PoolMintPager(opts)
	if err != nil {
		return nil, err
	}

	if uvm, err = pager.applyFilter(uvm); err != nil {
		return nil, err
	}

	conn := &UniswapV3PoolMintConnection{Edges: []*UniswapV3PoolMintEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvm.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvm.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvm = pager.applyCursors(uvm, after, before)
	uvm = pager.applyOrder(uvm, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvm = uvm.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvm = uvm.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvm.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3PoolMint
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3PoolMint {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3PoolMint {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3PoolMintEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3PoolMintEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3PoolMintOrderField defines the ordering field of UniswapV3PoolMint.
type UniswapV3PoolMintOrderField struct {
	field    string
	toCursor func(*UniswapV3PoolMint) Cursor
}

// UniswapV3PoolMintOrder defines the ordering of UniswapV3PoolMint.
type UniswapV3PoolMintOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *UniswapV3PoolMintOrderField `json:"field"`
}

// DefaultUniswapV3PoolMintOrder is the default ordering of UniswapV3PoolMint.
var DefaultUniswapV3PoolMintOrder = &UniswapV3PoolMintOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3PoolMintOrderField{
		field: uniswapv3poolmint.FieldID,
		toCursor: func(uvm *UniswapV3PoolMint) Cursor {
			return Cursor{ID: uvm.ID}
		},
	},
}

// ToEdge converts UniswapV3PoolMint into UniswapV3PoolMintEdge.
func (uvm *UniswapV3PoolMint) ToEdge(order *UniswapV3PoolMintOrder) *UniswapV3PoolMintEdge {
	if order == nil {
		order = DefaultUniswapV3PoolMintOrder
	}
	return &UniswapV3PoolMintEdge{
		Node:   uvm,
		Cursor: order.Field.toCursor(uvm),
	}
}

// UniswapV3PoolSwapEdge is the edge representation of UniswapV3PoolSwap.
type UniswapV3PoolSwapEdge struct {
	Node   *UniswapV3PoolSwap `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// UniswapV3PoolSwapConnection is the connection containing edges to UniswapV3PoolSwap.
type UniswapV3PoolSwapConnection struct {
	Edges      []*UniswapV3PoolSwapEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// UniswapV3PoolSwapPaginateOption enables pagination customization.
type UniswapV3PoolSwapPaginateOption func(*uniswapV3PoolSwapPager) error

// WithUniswapV3PoolSwapOrder configures pagination ordering.
func WithUniswapV3PoolSwapOrder(order *UniswapV3PoolSwapOrder) UniswapV3PoolSwapPaginateOption {
	if order == nil {
		order = DefaultUniswapV3PoolSwapOrder
	}
	o := *order
	return func(pager *uniswapV3PoolSwapPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3PoolSwapOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3PoolSwapFilter configures pagination filter.
func WithUniswapV3PoolSwapFilter(filter func(*UniswapV3PoolSwapQuery) (*UniswapV3PoolSwapQuery, error)) UniswapV3PoolSwapPaginateOption {
	return func(pager *uniswapV3PoolSwapPager) error {
		if filter == nil {
			return errors.New("UniswapV3PoolSwapQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3PoolSwapPager struct {
	order  *UniswapV3PoolSwapOrder
	filter func(*UniswapV3PoolSwapQuery) (*UniswapV3PoolSwapQuery, error)
}

func newUniswapV3PoolSwapPager(opts []UniswapV3PoolSwapPaginateOption) (*uniswapV3PoolSwapPager, error) {
	pager := &uniswapV3PoolSwapPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3PoolSwapOrder
	}
	return pager, nil
}

func (p *uniswapV3PoolSwapPager) applyFilter(query *UniswapV3PoolSwapQuery) (*UniswapV3PoolSwapQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3PoolSwapPager) toCursor(uvs *UniswapV3PoolSwap) Cursor {
	return p.order.Field.toCursor(uvs)
}

func (p *uniswapV3PoolSwapPager) applyCursors(query *UniswapV3PoolSwapQuery, after, before *Cursor) *UniswapV3PoolSwapQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3PoolSwapOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3PoolSwapPager) applyOrder(query *UniswapV3PoolSwapQuery, reverse bool) *UniswapV3PoolSwapQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3PoolSwapOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3PoolSwapOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3PoolSwap.
func (uvs *UniswapV3PoolSwapQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3PoolSwapPaginateOption,
) (*UniswapV3PoolSwapConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3PoolSwapPager(opts)
	if err != nil {
		return nil, err
	}

	if uvs, err = pager.applyFilter(uvs); err != nil {
		return nil, err
	}

	conn := &UniswapV3PoolSwapConnection{Edges: []*UniswapV3PoolSwapEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uvs.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uvs.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uvs = pager.applyCursors(uvs, after, before)
	uvs = pager.applyOrder(uvs, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uvs = uvs.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uvs = uvs.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uvs.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3PoolSwap
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3PoolSwap {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3PoolSwap {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3PoolSwapEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3PoolSwapEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3PoolSwapOrderField defines the ordering field of UniswapV3PoolSwap.
type UniswapV3PoolSwapOrderField struct {
	field    string
	toCursor func(*UniswapV3PoolSwap) Cursor
}

// UniswapV3PoolSwapOrder defines the ordering of UniswapV3PoolSwap.
type UniswapV3PoolSwapOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *UniswapV3PoolSwapOrderField `json:"field"`
}

// DefaultUniswapV3PoolSwapOrder is the default ordering of UniswapV3PoolSwap.
var DefaultUniswapV3PoolSwapOrder = &UniswapV3PoolSwapOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3PoolSwapOrderField{
		field: uniswapv3poolswap.FieldID,
		toCursor: func(uvs *UniswapV3PoolSwap) Cursor {
			return Cursor{ID: uvs.ID}
		},
	},
}

// ToEdge converts UniswapV3PoolSwap into UniswapV3PoolSwapEdge.
func (uvs *UniswapV3PoolSwap) ToEdge(order *UniswapV3PoolSwapOrder) *UniswapV3PoolSwapEdge {
	if order == nil {
		order = DefaultUniswapV3PoolSwapOrder
	}
	return &UniswapV3PoolSwapEdge{
		Node:   uvs,
		Cursor: order.Field.toCursor(uvs),
	}
}

// UniswapV3TransferEdge is the edge representation of UniswapV3Transfer.
type UniswapV3TransferEdge struct {
	Node   *UniswapV3Transfer `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// UniswapV3TransferConnection is the connection containing edges to UniswapV3Transfer.
type UniswapV3TransferConnection struct {
	Edges      []*UniswapV3TransferEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

// UniswapV3TransferPaginateOption enables pagination customization.
type UniswapV3TransferPaginateOption func(*uniswapV3TransferPager) error

// WithUniswapV3TransferOrder configures pagination ordering.
func WithUniswapV3TransferOrder(order *UniswapV3TransferOrder) UniswapV3TransferPaginateOption {
	if order == nil {
		order = DefaultUniswapV3TransferOrder
	}
	o := *order
	return func(pager *uniswapV3TransferPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUniswapV3TransferOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUniswapV3TransferFilter configures pagination filter.
func WithUniswapV3TransferFilter(filter func(*UniswapV3TransferQuery) (*UniswapV3TransferQuery, error)) UniswapV3TransferPaginateOption {
	return func(pager *uniswapV3TransferPager) error {
		if filter == nil {
			return errors.New("UniswapV3TransferQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type uniswapV3TransferPager struct {
	order  *UniswapV3TransferOrder
	filter func(*UniswapV3TransferQuery) (*UniswapV3TransferQuery, error)
}

func newUniswapV3TransferPager(opts []UniswapV3TransferPaginateOption) (*uniswapV3TransferPager, error) {
	pager := &uniswapV3TransferPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUniswapV3TransferOrder
	}
	return pager, nil
}

func (p *uniswapV3TransferPager) applyFilter(query *UniswapV3TransferQuery) (*UniswapV3TransferQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *uniswapV3TransferPager) toCursor(uv *UniswapV3Transfer) Cursor {
	return p.order.Field.toCursor(uv)
}

func (p *uniswapV3TransferPager) applyCursors(query *UniswapV3TransferQuery, after, before *Cursor) *UniswapV3TransferQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultUniswapV3TransferOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *uniswapV3TransferPager) applyOrder(query *UniswapV3TransferQuery, reverse bool) *UniswapV3TransferQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultUniswapV3TransferOrder.Field {
		query = query.Order(direction.orderFunc(DefaultUniswapV3TransferOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to UniswapV3Transfer.
func (uv *UniswapV3TransferQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UniswapV3TransferPaginateOption,
) (*UniswapV3TransferConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUniswapV3TransferPager(opts)
	if err != nil {
		return nil, err
	}

	if uv, err = pager.applyFilter(uv); err != nil {
		return nil, err
	}

	conn := &UniswapV3TransferConnection{Edges: []*UniswapV3TransferEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := uv.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := uv.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	uv = pager.applyCursors(uv, after, before)
	uv = pager.applyOrder(uv, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		uv = uv.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		uv = uv.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := uv.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *UniswapV3Transfer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UniswapV3Transfer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UniswapV3Transfer {
			return nodes[i]
		}
	}

	conn.Edges = make([]*UniswapV3TransferEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &UniswapV3TransferEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// UniswapV3TransferOrderField defines the ordering field of UniswapV3Transfer.
type UniswapV3TransferOrderField struct {
	field    string
	toCursor func(*UniswapV3Transfer) Cursor
}

// UniswapV3TransferOrder defines the ordering of UniswapV3Transfer.
type UniswapV3TransferOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *UniswapV3TransferOrderField `json:"field"`
}

// DefaultUniswapV3TransferOrder is the default ordering of UniswapV3Transfer.
var DefaultUniswapV3TransferOrder = &UniswapV3TransferOrder{
	Direction: OrderDirectionAsc,
	Field: &UniswapV3TransferOrderField{
		field: uniswapv3transfer.FieldID,
		toCursor: func(uv *UniswapV3Transfer) Cursor {
			return Cursor{ID: uv.ID}
		},
	},
}

// ToEdge converts UniswapV3Transfer into UniswapV3TransferEdge.
func (uv *UniswapV3Transfer) ToEdge(order *UniswapV3TransferOrder) *UniswapV3TransferEdge {
	if order == nil {
		order = DefaultUniswapV3TransferOrder
	}
	return &UniswapV3TransferEdge{
		Node:   uv,
		Cursor: order.Field.toCursor(uv),
	}
}
